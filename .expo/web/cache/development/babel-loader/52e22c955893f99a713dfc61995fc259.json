{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as SQLite from 'expo-sqlite';\nimport AddrItem from \"../screens/AddrItem\";\nvar db = SQLite.openDatabase('address.db');\nexport var init = function init() {\n  var promise = new Promise(function (accept, reject) {\n    db.transaction(function (tx) {\n      tx.executeSql('CREATE TABLE IF NOT EXISTS address (id INTEGER PRIMARY KEY NOT NULL, address TEXT NOT NULL, lat REAL NOT NULL, lng REAL NOT NULL)'), [], function () {\n        accept();\n      }, function (_, err) {\n        reject(err);\n      };\n    });\n  });\n  return promise;\n};\nexport var removeAddr = function removeAddr() {\n  db.transaction(function (tx) {\n    tx.executeSql('DELETE * FROM address;', []);\n  });\n};\nexport var insertAddress = function insertAddress(address, lat, lng) {\n  var promise;\n  return _regeneratorRuntime.async(function insertAddress$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          promise = new Promise(function (resolve, reject) {\n            db.transaction(function (tx) {\n              tx.executeSql('INSERT INTO address (address, lat, lng) VALUES (?, ?, ?);', [address, lat, lng], function (_, result) {\n                return resolve(result);\n              }, function (_, error) {\n                return reject(error);\n              });\n            });\n          });\n          return _context.abrupt(\"return\", promise);\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\nexport var fetchAddresses = function fetchAddresses() {\n  var promise;\n  return _regeneratorRuntime.async(function fetchAddresses$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          promise = new Promise(function (resolve, reject) {\n            db.transaction(function (tx) {\n              tx.executeSql('SELECT * from address;', [], function (_, result) {\n                return resolve(result);\n              }, function (_, error) {\n                return reject(error);\n              });\n            });\n          });\n          return _context2.abrupt(\"return\", promise);\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\nexport var fetchAddr = function fetchAddr() {\n  return _regeneratorRuntime.async(function fetchAddr$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          db.transaction(function (tx) {\n            tx.executeSql('SELECT * FROM address', [], function (tx, results) {\n              if (results.rows._array[0]) {\n                console.log(results.rows._array[0].address);\n                render();\n                return React.createElement(AddrItem, {\n                  addr: results.rows._array[0].address\n                });\n              }\n            });\n          });\n\n        case 1:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};","map":{"version":3,"sources":["/home/ggatica/Escritorio/ProyectoEntrega/db/index.js"],"names":["SQLite","AddrItem","db","openDatabase","init","promise","Promise","accept","reject","transaction","tx","executeSql","_","err","removeAddr","insertAddress","address","lat","lng","resolve","result","error","fetchAddresses","fetchAddr","results","rows","_array","console","log","render"],"mappings":"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","sourcesContent":["import * as SQLite from 'expo-sqlite'\nimport AddrItem from '../screens/AddrItem'\n\nconst db = SQLite.openDatabase('address.db')\n\n//Inicializamos la base de datos de SQLite\nexport const init = () => {\n    const promise = new Promise ((accept, reject) => {\n        db.transaction((tx)=> {\n            tx.executeSql('CREATE TABLE IF NOT EXISTS address (id INTEGER PRIMARY KEY NOT NULL, address TEXT NOT NULL, lat REAL NOT NULL, lng REAL NOT NULL)'),\n            [],\n            () => { accept()},\n            (_, err) => { reject(err)}\n        })\n    })\n    return promise;\n}\nexport const removeAddr = () => {\n\tdb.transaction((tx) => {\n\t\ttx.executeSql('DELETE * FROM address;', []);\n\t});\n};\nexport const insertAddress = async (\n    address,\n    lat,\n    lng\n) => {\n    const promise = new Promise((resolve, reject) =>{\n        db.transaction((tx)=> {\n            tx.executeSql(\n                'INSERT INTO address (address, lat, lng) VALUES (?, ?, ?);',\n                [address, lat, lng],\n                (_, result) => resolve(result),\n                (_, error) => reject(error),\n            )\n        })\n    } )\n    return promise\n}\n\nexport const fetchAddresses = async () => {\n    const promise = new Promise((resolve, reject) =>{\n        db.transaction((tx)=> {\n            tx.executeSql(\n                'SELECT * from address;',\n                [],\n                (_, result) => resolve(result),\n                (_, error) => reject(error),\n            )\n        })\n    } )\n    return promise\n}\n\nexport const fetchAddr = async () => {\n\tdb.transaction((tx) => {\n\t\ttx.executeSql('SELECT * FROM address', [], (tx, results) => {\n\t\t\tif (results.rows._array[0]) {\n                console.log(results.rows._array[0].address)\n                render()\n\t\t\t\treturn (<AddrItem addr={results.rows._array[0].address}/>)\n\t\t\t}\n\t\t});\n\t});\n   \n};"]},"metadata":{},"sourceType":"module"}